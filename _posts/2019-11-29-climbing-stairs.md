---
layout: single
title:  "[알고리즘] Leetcode 70. Climbing Stairs (Easy) 풀이"
date:   2021-03-16
category: algorithm
tags: [algorithm, C++]
---

이 포스팅에서는 [Leetcode - 70.Climbing Stairs (Easy)](1)를 풀어보며 느꼈던 점을 정리하였습니다.

## The Problem

*원문으로 설명된 문제는 [문제 링크](1)를 참고하세요.*

```console
당신은 계단을 오르고 있습니다.
꼭대기에 도착하려면 n개의 계단을 올라야 합니다.
한 번에 1개 혹은 2개의 계단씩 오를 수 있습니다.
꼭대기까지 올라갈 수 있는 방법은 총 몇 가지일까요?
단, n은 양의 정수입니다.

- 예시 1:
    입력: 2
    출력: 2
    설명: 2개의 계단을 올라야 꼭대기에 도착하는 경우, 총 2가지 방법으로 오를 수 있습니다.
    1. 1계단 + 1계단
    2. 2계단

- 예시 2:
    입력: 3
    출력: 3
    설명: 3개의 계단을 올라야 꼭대기에 도착하는 경우, 총 3가지 방법으로 오를 수 있습니다.
    1. 1계단 + 1계단 + 1계단
    2. 1계단 + 2계단
    3. 2계단 + 1계단
```

## Trial

계단이 1개나 2개일 경우, 간단하게 `f(n)=n`이라는 솔루션이 나옵니다.

```console
f(1): 1가지
1계단
```

```console
f(2): 2가지
1 + 1
2
```

계단이 3개일 경우, 처음 시작할 때 1계단 또는 2계단을 오르도록 할 수 있습니다. 처음에 1계단을 올랐다면, 나머지 2개의 계단을 오르기 위해 2가지 방법이 있을 것이고, 처음에 2계단을 올랐다면 남은 1개의 계단을 오르기 위해 1가지 방법이 있을 것입니다.

**다시 말해, 3개의 계단을 오르는 것은 처음에 1계단을 오른 후 나머지 2계단을 오르는 경우의 수와, 처음에 2계단을 오른 후 나머지 1계단을 오르는 경우의 수를 합한 것과 같습니다.**

```console
f(3): 3 ways
1 + 1 + 1
1 +     2
2 +     1
```

따라서, 다음 식이 성립됩니다:
`f(3) = f(3-1) + f(3-2) = f(2) + f(1) = 2 + 1 = 3`
총 3가지 방법이 나옵니다.

다음으로, 계단이 4개일 경우는 어떨까요?

```console
f(4): 5 ways
1 + 1 + 1 + 1
1 + 1 +     2
1 + 2 +     1
2 +     1 + 1
2 +     2
```

마찬가지로, 처음에 1개를 오른 후 나머지 3개를 오르는 경우의 수와, 처음에 2개를 오른 후 나머지 2개를 오르는 경우의 수를 합하면 됩니다.

즉,
`f(4) = f(4-1) + f(4-2) = f(3) + f(2) = 3 + 2 = 5`
총 5가지 방법이 나옵니다.

이 규칙에 대한 식을 세우면 다음과 같습니다.

```console
f(n) = n,               {n = 1, 2}
     = f(n-1) + f(n-2), {n >= 3}
```

규칙을 찾았으니, 그 규칙대로 재귀 함수를 만들면 되겠다고 생각해서 다음과 같이 코드를 짜봤습니다.

```cpp
int climbStairs(int n) {
    return doClimbStairs(n);
}

int doClimbStairs(int n) {
    // Edge case
    if(n == 1 || n == 2) {
        return n;
    }

    // f(n) = f(n-1) + f(n-2)
    return doClimbStairs(n - 1) + doClimbStairs(n - 2);

}
```

괜찮아 보였습니다. **겹치는 계산이 엄청나게 많다는 것을 알기 전까지는요.**

코딩을 마치고 테스트 케이스에 1, 2 같은 edge case는 물론이고, 5, 7, 10 등 그보다 큰 몇 가지 숫자를 넣어도 테스트를 잘 통과했습니다.

그런데 문제는, 조금 더 큰 case를 테스트 해보려고 100을 넣었더니 Time exceeding 오류가 나는 것이었습니다.

문제를 파악하기 위해 `f(n)`을 계산하기 위해 필요한 함수 결과인 `f(n-1)`과 `f(n-2)`를 `f(n)`의 자식으로 하여 트리의 형태로 그려보았습니다. Naive하게 코드를 작성했을 때는 몰랐던 문제점들이 나타났습니다.

![f(6)](/assets/images/climb-stairs/f-6.png)

잘 보면, `f(1)`은 총 3번, `f(2)`는 총 5번, `f(3)`은 총 3번, `f(4)`는 총 2번 불렸습니다. 그러니까, 한 번만 계산해도 될 것을 몇 번이고 계속 같은 계산을 했던 것입니다. `f(6)`의 경우라서 망정이지, `f(20)`에선 얼마나 끔찍한 일이 일어났을까요?

이게 얼마나 큰 실수인지, 대략적인 시간 복잡도를 구해봅시다. 이진 트리이기 때문에, 각 부모 노드가 2개의 자식 노드를 만드므로, 시간 복잡도는 O(2<sup>n</sup>)이 됩니다. 쉽게 말하자면, n이 주어졌을 때, `doClimbStairs(int n)` 함수가 2<sup>n</sup>번 호출된다는 뜻입니다.

O(2<sup>n</sup>)는 알고리즘적으로 봤을 때 최악에 가까운 시간복잡도입니다.

![Plot of 2 to the power of n](/assets/images/climb-stairs/algo-complexity.png)

`n=10`을 기점으로 2<sup>n</sup>, n 사이의 간격이 급격히 벌어지고, `n=100` 이상 되면 어떻게 될지는 그림에서 보듯 뻔합니다. n<sup>2</sup>도 성능이 좋지 않은 축이 속하지만 (로직에 따라 어쩔 수 없는 상황은 있겠지만,) 그보다 훨씬 시간복잡도가 높은 2<sup>n</sup>는 얼마나 느릴지 상상도 할 수 없습니다.

이런 경우, 시간 측면에서 문제가 있을 뿐만 아니라, Call stack에 함수 call이 계속 쌓이게 되어, Stack overflow 문제가 발생할 가능성이 매우 큽니다.

## 해결

해결법은 한 번 계산한 것을 다시 계산하지 않도록 계산 결과를 저장하는 것입니다. 흔히 이걸 메모해놓고 나중에 사용하는 것과 비슷하다고 해서 **Memoization** 기법이라고 부릅니다.

`f(6)`을 그렸던 그림을 다시 참고해 봅시다. 여기서 우리는 `f(1), f(2), ..., f(6)`의 계산 결과를 한 번만 수행하고, 수행 결과를 길이 6짜리의 배열에 저장하여 나중에 필요할 때 꺼내주면 됩니다.

Memoization을 이용해 개선한 알고리즘의 솔루션입니다.

```cpp
int climbStairs(int n) {
    // Edge case
    if(n == 1 || n == 2)
        return n;

    int* memo = new int[n + 1]; // start from 1

    memo[1] = 1;
    memo[2] = 2;

    return doClimbStairs(n, memo);     
}

int doClimbStairs(int n, int* memo) {
    if(memo[n] > 0) {
        return memo[n];
    }

    // memo[n] = f(n-2) + f(n-1)
    memo[n] = doClimbStairs(n - 2, memo) + doClimbStairs(n - 1, memo);

    return memo[n];
}
```

## 고민

아래 코드에서 `n-2`의 경우를 `n-1`의 경우보다 먼저 계산한 것은, memoization의 특성 상 작은 수부터 계산하면 더 빠를 것 같다는 생각때문이었습니다.

```cpp
memo[n] = doClimbStairs(n - 2, memo) + doClimbStairs(n - 1, memo);
```

Leetcode에서 제출했을 때, 두 경우 모두 0ms로 나와 직접적인 비교가 힘들었지만, 다음에 시간이 나면 직접 프로그램을 짜서 알아봐야겠습니다.

# Reference
1. [Leetcode - Climbing Stars](1)

[1]: https://leetcode.com/problems/climbing-stairs
